## This is the text editor interface. 
## Anything you type or change here will be seen by the other person in real time.
## Ready!

A: 1000
B: 1000
C: 2000


Pay a bond
A 500

A: 500
B: 1000
C: 2000




Pay bonds sequential

sequential:
- A
- B
- C

1500

A: 0
B: 500
C: 2000



Pay bonds prorata

prorata:
- A
- B
- C

1000

A: 1000
B: 1000
C: 2000
total: 4000

a_amount = (a_balance / total_balance) * amount

A: (1000/4000)*1000 = 250 -> 750
B: (1000/4000)*1000 = 250 -> 750
C: (2000/4000)*1000 = 500 -> 1500
    
sequential:
- prorata:
  - A
  - B
- C

a_and_b_amount = ((a_balance + b_balance) / total_balance) * amount

prorata:
- sequential:
  - A
  - B
- C



List of steps:
    
Pick a data structure to represent our 'structure' of nested rules
Pick a data structure to represent our bond balances
Write a function signature for 'pay'
Implement pay

prorata:
- sequential:
  - A
  - B
- C

seq(list)
pay(list)

pro(list)
pay(list)

class Node:
    def __init__(self):
        self.type = None #'prorata' or 'sequential' or 'bond'
        self.children = None
        self.name = None # e.g. 'A'
        self.balance = None # ?


seq = sequential(['A', 'B'])
pro = prorata([seq1, 'C'])

def pay(root, amount):
    if root.type = 'bond':
        if (root.balance < amount):
            root.balance = 0
            amount = amount - root.balance
        else:
            root.balance = root.balance - amount
            amount = 0
    
    if root.type = 'prorata':
        # Correctly set root.balance
        orig_root_balance = root.balance
        if (root.balance < amount):
            root.balance = 0
        else:
            root.balance = root.balance - amount
        
        for node in root.children:
            amount_to_pay_to_node = (node.balance / orig_root_balance) * amount
            pay(node, amount_to_pay_to_node)
        
    if root.type = 'sequential':
        # Correctly set root.balance
        if (root.balance < amount):
            root.balance = 0
        else:
            root.balance = root.balance - amount
            
        for node in root.children:
            node_balance = node.balance
            pay(node, amount)
            amount = max(0.0,amount - node_balance)
    
    






